The TRex Scapy RPC Server
=========================
:Author: Itamar Raviv
:email: trex-dev@cisco.com
:revnumber: 1.00
:quotes.++:
:numbered:
:web_server_url: https://trex-tgn.cisco.com/trex
:local_web_server_url: csi-wiki-01:8181/trex
:toclevels: 4

include::trex_ga.asciidoc[]

== Change log

[options="header",cols="^1,^h,3a"]
|=================
| Version |  name   |  meaning
| 1.00    |  Itamar Raviv (itraviv) |
- first version

|=================


== Audience of this document 

TRex GUI guys

== Scapy RPC Server - Overview
Scapy Server is implemented following the link:http://www.jsonrpc.org/specification[JSON-RPC 2.0 specification], +
Therefore, requests and replies follow the JSON-RPC 2.0 spec. +
The server operates on a Request-Response basis *over ZMQ*, and does not support batched commands handling. +

Read more about ZMQ link:http://zguide.zeromq.org/page:all[here]

image::images/Scapy_JSON_rpc_server.png[title="Scapy JSON RPC Server",align="left",width=800, link="images/Scapy_JSON_rpc_server.png"]

=== Error Codes

Error codes are given according to this table: [also follows the JSON-RPC spec, with added error codes]

[options="header",cols="^1,^h,3a"]
|=================
| Error Code   |  Message                    |  Meaning
| -32700       | Parse Error                 | Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.
| -32600       | Invalid Request             | The JSON sent is not a valid Request object.
| -32601       | Method not found            | The method does not exist / is not available
| -32603       | Invalid params              |  Invalid method parameter(s)
| -32097       | Syntax Error                |  Syntax Error in input
| -32098       |  Scapy Server: message | Scapy Server had an error while executing your command, described in the message given
| -32096       | Scapy Server: Unknown Error | Scapy Server encountered an error that cannot be described


|=================



== Data Bases and Data Structures used in Scapy Server
=== Protocol Field Description
This data sturcture contains the name of the field, its type and the default value assigned. +
 +
Has the following structure: +


(field name, field type, default value) +


*Example:* +
this is the 'dst' field for the 'Ether' protocol
[source,bash]
----
["dst","MACField","('00:00:00:01:00:00')"]

----


=== Offsets Dictionary and Offset Entry
==== The *"Offset Entry"* data sturcture contains the offset of a field within the *layer*, and its size. +
(both measured in Bytes)
 +
 +
Has the following structure: +
 +
[field offset (within the layer), field size] +



*Example:* +
This is the 'src' field for the 'IP' protocol: +
the offset within the layer is 16 bytes, and the size of the field is 4 bytes (as defined in the IP spec)
[source,bash]
----
'dst': [16, 4]
----

==== The *"Offsets Dictionary"* data sturcture simply maps the offsets for each layer according to name. +
Has the following structure: +
 +
 'field name' : [ field offset, field size ] // i.e Offset entry
 +



*Example:* +
This is the Offsets Dictionary for the IP layer: +
[source,bash]
----
'offsets': {'IP': {'chksum': [10, 2],
                   'dst': [16, 4],
                   'flags': [6, 0],
                   'frag': [6, 0],
                   'global_offset': 0,
                   'id': [4, 2],
                   'ihl': [0, 0],
                   'len': [2, 2],
                   'options': [20, 2],
                   'proto': [9, 1],
                   'src': [12, 4],
                   'tos': [1, 1],
                   'ttl': [8, 1],
                   'version': [0, 0]
                  }
           }
----


Each layer has a 'global_offset' key. this key represents the *offset of the layer within the packet*. +
In the example above, the IP layer starts at offset 0, and the field src is at offset 12 within the packet. +
In the general case, a field's offset within the *packet* is calculated this way: +
 'global_offset' + 'field_offset'


=== Protocol Dictionary
The protocol dictionary contains the names for all supported protocols and layers for building packets. +
Each entry in this data base has the following format: +
'Protocol Name' : 'Protocol Field Description' +
 +


*Example*: +
[source,bash]
----
{ "Ether":[
            ["dst","MACField","('00:00:00:01:00:00')"],
            ["src","MACField","('00:00:00:02:00:00')"],
            ["type", "XShortEnumField", "(36864)"]
          ],
  "ARP":[
            ["hwtype", "XShortField", "(1)"],
            ["ptype", "XShortEnumField", "(2048)"],
            ["hwlen", "ByteField", "(6)"],
            ["plen", "ByteField", "(4)"],
            ["op", "ShortEnumField", "(1)"],
            ["hwsrc", "ARPSourceMACField", "(None)"],
            ["psrc", "SourceIPField", "(None)"],
            ["hwdst", "MACField", "(\'00:00:00:00:00:00\')"],
            ["pdst", "IPField", "(\'0.0.0.0\')"]
        ],
  .
  .
  .
  .
}
----

=== Fields Dictionary
The fields dictionary contains mapping between a field's name and its regular expression, +
Which has the following structure: +
(field name, field RegEx) +

Example: this is the Regex for the 'MACField' protocol
[source,bash]
----
{'MACField': '^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$'}
----

The dictionary maintains its regular structure:
[source,bash]
----
{'MACField': '^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$'
 'IPField': 'IP_FIELD_REGEX'
 .
 .
 .
}
----

== RPC Commands
The following RPC commands are supported. please refer to data bases section for elaboration on given data bases

=== Supported Methods
* *Name* - supported_methods
* *Description* - returns the list of all supported methods by Scapy Server and their parameters
* *Parameters* - a single empty string ('') will return *ALL* supported methods. +
 other string delivered as parameter will return True/False if the string matches a supported method name
* *Result* - according to input: empty string will return list of supported methods, otherwise will return True/False as mentioned

*Example:*

[source, bash]
----
'Request':
{
        "jsonrpc": "2.0",
        "id": "1",
        "method": "supported_methods",
        "params": [""]
}

'Result':
{'id': '1',
 'jsonrpc': '2.0',
 'result': { .
             .
             .
             .
             'build_pkt': [1, [u'pkt_descriptor']],
             'check_update': [2, [u'db_md5', u'field_md5']],
             'get_all': [0, []],
             'get_tree': [0, []],
             'get_version': [0, []],
             'supported_methods': [1, [u'method_name']]
           }
}
----



=== GetAll
* *Name* - 'get_all'
* *Description* - Returns the supported protocols library (DB) and Field-to-RegEx mapping library, and their MD5 
* *Paramters* - None
* *Result* ['object'] - JSON format of dictionary. see table below

.Object type 'return values for get_all' 
[options="header",cols="1,1,3,3"]
|=================
| Key             | Key Type      | Value                           | Value Type 
| db              | string        | supported protocols dictionary  | protocol dictionary
| fields          | string        | Field-to-RegEx dictionary       | Field-to-RegEx dictionary
| db_md5          | string        |  MD5 of DB                      | encoded in base64
| fields_md5      | string        |  MD5 of fields                  | encoded in base64
|=================

*Example:*

[source,bash]
----
'Request':
{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "get_all",
    "params": []
}

'Response':
{
   "jsonrpc" : "2.0",
   "id" : 1,
   "result" : {'db': {'ARP': [('hwtype', 'XShortField', '(1)'),
                              ('ptype', 'XShortEnumField', '(2048)'),
                              ('hwlen', 'ByteField', '(6)'),
                              ('plen', 'ByteField', '(4)'),
                              ('op', 'ShortEnumField', '(1)'),
                              ('hwsrc', 'ARPSourceMACField', '(None)'),
                              ('psrc', 'SourceIPField', '(None)'),
                              ('hwdst', 'MACField', "('00:00:00:00:00:00')"),
                              ('pdst', 'IPField', "('0.0.0.0')")],
                              .
                              .
                              .
               'db_md5': 'Z+gRt88y7SC0bDu496/DQg==\n',
               'fields': {'ARPSourceMACField': 'empty',
                          'BCDFloatField': 'empty',
                          'BitEnumField': 'empty',
                          .
                          .
                          .

}

----

=== Check if DataBase is updated
* *Name* - 'check_update'
* *Description* - checks if both protocol database and fields database are up to date according to md5 comparison
* *Paramters* - md5 of database, md5 of fields
* *Result* - upon failure: error code -32098 (see link:trex_scapy_rpc_server.html#_error_codes[RPC server error codes]) +
             followed by a message: "Fields DB is not up to date" or "Protocol DB is not up to date" +
             upon success: return 'true' as result (see below) +
 +
*Example:*

[source,bash]
----
'Request':

{
        "jsonrpc": "2.0",
        "id": "1",
        "method": "check_update",
        "params": ["md5_of_protocol_db", "md5_of_fields"]   
}

'Response': //on failure

{
        "jsonrpc": "2.0",
        "id": "1",
        "error": {
                  "code": -32098,
                  "message:": "Scapy Server: Fields DB is not up to date"
                 }
}

'Response': //on success

{
        "jsonrpc": "2.0",
        "id": "1",
        "result": true
}
----


=== Get Version
* *Name* - 'get_version'
* *Description* - Queries the server for version information
* *Paramters* - None
* *Result* ['object'] - See table below

.Object type 'return values for get_version' 
[options="header",cols="1,1,3"]
|=================
| Field         | Type     | Description 
| version       | string   | Scapy Server version
| built_by      | string   | who built this version
|=================


*Example:*
[source,bash]
----

'Request':

{
        "jsonrpc": "2.0",
        "id": "1",
        "method": "get_version", 
        "params": []
}



'Response':

{
        "jsonrpc": "2.0",
        "id": "1",
        "result": {
                "version": "v1.0",
                "built_by": "itraviv"
        }
}

----

=== Build Packet
* *Name* - 'build_pkt'
* *Description* - Takes a JSON format string of a SCAPY packet. +
* *Return Value* - See table below
* *Paramters* - string describing SCAPY packet
* *Result* ['dictionary'] - a dictionary that contains:  + 
* pkt buffer (Hexdump encoded in base64) + 
* pkt offsets - each field within the packet has its offset within the layer, and the field size + 
 the value returned is [ 'field offset' , 'field size' ] + 
* pkt show2 - a detailed description of each field and its value



.Object type 'return values for build_pkt' 
[options="header",cols="1,1,3"]
|=================
| Field         | Type     | Description 
| pkt buffer       | Hexdump encoded in base64   | The packet's dump
| pkt offsets      | Dictionary of layers   | Each layer contains it's offsets within the layer, and a global offset within the packet
| pkt show2        | Dictionary of layers | Each layer is a dictionary of fields, which contains the values for each field
|=================

*Example:* +
Successful assembly of a packet: +
[source,bash]
----

'Request':

{
    "id": "1",
    "jsonrpc": "2.0",
    "method": "build_pkt",
    "params": ["Ether()/IP(src='127.0.0.1')/TCP(sport=80)"]
}

'Response':

{
    'id': '1',
    'jsonrpc': '2.0',
    'result': { 'buffer': 'AAAAAQAAAAAAAgAACABFAAAoAAEAAEAGy81/AAABMAAAAQBQAFAAAAAAAAAAAFACIADgQAAA\n',
                'offsets':{
                           'Ether': {
                                     'dst': [0, 6],
                                     'global_offset': 0,
                                     'src': [6, 6],
                                     'type': [12, 2]
                                     },
                           'IP': {
                                     'chksum': [10, 2],
                                     'dst': [16, 4],
                                     'flags': [6, 0],
                                     'frag': [6, 0],
                                     'global_offset': 14,
                                     'id': [4, 2],
                                     'ihl': [0, 0],
                                     'len': [2, 2],
                                     'options': [20, 2],
                                     'proto': [9, 1],
                                     'src': [12, 4],
                                     'tos': [1, 1],
                                     'ttl': [8, 1],
                                     'version': [0, 0]
                                  },
                           'TCP': {
                                   'ack': [8, 4],
                                   'chksum': [16, 2],
                                   'dataofs': [12, 0],
                                   'dport': [2, 2],
                                   'flags': [13, 0],
                                   'global_offset': 34,
                                   'options': [20, 2],
                                   'reserved': [12, 0],
                                   'seq': [4, 4],
                                   'sport': [0, 2],
                                   'urgptr': [18, 2],
                                   'window': [14, 2]
                                   }
                          },
                'show2': {
                                'Ethernet': {
                                                'dst': '00:00:00:01:00:00',
                                                'src': '00:00:00:02:00:00',
                                                'type': '0x800'
                                             },
                                'IP': {
                                                'chksum': '0xcbcd',
                                                'dst': '48.0.0.1',
                                                'flags': '',
                                                'frag': '0L',
                                                'id': '1',
                                                'ihl': '5L',
                                                'len': '40',
                                                'proto': 'tcp',
                                                'src': '127.0.0.1',
                                                'tos': '0x0',
                                                'ttl': '64',
                                                'version': '4L'
                                       },
                                'TCP': {
                                                 'ack': '0',
                                                 'chksum': '0xe040',
                                                 'dataofs': '5L',
                                                 'dport': '80',
                                                 'flags': 'S',
                                                 'options': '{}',
                                                 'reserved': '0L',
                                                 'seq': '0',
                                                 'sport': '80',
                                                 'urgptr': '0',
                                                 'window': '8192'
                                        }
                          }
               }
}


----

Unsuccessful assembly of a packet: +
[source,bash]
----

'Request':

{
    "id": "zweuldlh",
    "jsonrpc": "2.0",
    "method": "build_pkt",
    "params": "ETHER()-IP()"  //not a valid SCAPY packet string
}

'Response':

{
    'id': 'zweuldlh',
    'jsonrpc': '2.0',
    'error': {
                'code': -32098,
                'message:': "Scapy Server: unsupported operand type(s) for -: 'Ether' and 'IP'"
             }
}
    
----

=== Get protocol tree hierarchy example
* *Name* - 'get_tree'
* *Description* - returns a *suggested* dictionary of protocols ordered in a hierarchy tree. +
User can still create non valid hierarchies. (such as Ether()/DNS()/IP())
* *Parameters* - none
* *Result* [dictionary] - Example for packet layers that can be used to build a packet. Ordered in an hierarchy tree.

*Example:*

[source,bash]
----

'Request':

{       
        "id": "1",
        "jsonrpc": "2.0",
        "method": "get_tree",
        "params": []
}


'Response':

{'id': '1',
 'jsonrpc': '2.0',
 'result': {'ALL': {
                        'Ether': {'ARP': {},
                                  'IP': {   'TCP': {'RAW': 'payload'},
                                            'UDP': {'RAW': 'payload'}
                                        }
                                 }
                    }
           }
}
----


== Usage of Scapy RPC Server
Notice the existance of the following files: 

* scapy_service.py 
* scapy_zmq_server.py 
* scapy_zmq_client.py 

=== Scapy_zmq_server.py
In this section we will see how to bring up the Scapy ZMQ server.
There are 2 ways to run this server:

* Through command line
* Through Python interpreter

==== Running Scapy ZMQ Server from command line
Run the file scapy_zmq_server.py with the argument -s to declare the port that the server will listen to. +
Running the file without the "-s" argument will use *port 4507 by default*. +
 +
Notice:

* The Server's IP will be the IP address of the local host.
* The Server will accept requests from *any* IP address on that port.

[source,bash]
----
user$ python scapy_zmq_server.py -s 5555

***Scapy Server Started***
Listening on port: 5555
Server IP address: 10.0.0.1

----

==== Running Scapy ZMQ Server from the Python interpreter
* Run the Python Interpreter (Scapy Server currently supports Python2)
* Import the scapy_zmq_server.py file
* Create a Scapy_server Object with argument as port number. default argument is port 4507
* Invoke method activate(). (This method is blocking because the server is listening on the port).

[source,bash]
----
user$ python
>>> from scapy_zmq_server import *
>>> s = Scapy_server() // starts with port 4507
>>> s = Scapy_server(5555) //starts with port 5555
>>> s.activate()
***Scapy Server Started***
Listening on port: 5555
Server IP address: 10.0.0.1

----

==== Shutting down Scapy ZMQ Server
There are 2 ways to shut down the server:

* The server can be shut down using the keyboard interrupt Ctrl+C
* The server can be shut down remotely with the method "shut_down" with no arguments

[source,bash]
----
//Sending Request: {"params": [], "jsonrpc": "2.0", "method": "shut_down", "id": "1"}
//Will result in this print by the server:
Server: Shut down by remote user
----






