The TRex RPC Server
===================
:author: Itay Marom
:email: <imarom@cisco.com>
:revnumber: 1.70-0.0
:quotes.++:
:numbered:
:web_server_url: http://trex-tgn.cisco.com/trex
:local_web_server_url: csi-wiki-01:8181/trex



== RPC Support On TRex

TRex implements a RPC protocol in order to config, view and
in general execute remote calls on TRex

In this document we will provide information on
how a client can implement the protocol used to communicate with TRex

In general, we will describe the following:

* *Transport Layer* - The transport layer used to communicate with TRex server
* *RPC Reprensentation Protocol* - The format in which remote procedures are carried

=== Transport Layer

TRex server transport layer is implemented using ZMQ.

The default configuration is TCP on port 5555, however this is configurable.

{zwsp} +
The communication model is based on the request-reply ZMQ model:

http://zguide.zeromq.org/page:all#Ask-and-Ye-Shall-Receive

{zwsp} +

for more on ZMQ and implementation please refer to:
{zwsp} +
http://zeromq.org/intro:read-the-manual

=== RPC Reprensentation Protocol

The RPC reprensentation protocol is JSON RPC v2.0.
Every request and response will be encoded in a JSON RPC v2.0 format.

{zwsp} +

For more info on JSON RPC v2.0 spec please refer to:
{zwsp} +

http://www.jsonrpc.org/specification

{zwsp} +

Later on in the document we will describe all the supported commands.

=== TRex RPC Mock Server
Before we get into the commands, it's worth mentioning that TRex has a mock RPC server
designed to allow playing around with the server in order to understand the response
and perform adjustments to the request.

TRex also provides a Python based console that can connect to the server (mock or real) and
send various commands to the server.

==== Building The Mock Server
Building the mock server is performed like this:
[source,bash]
----
trex-core/linux>  ./b configure
trex-core/linux>  ./b --target=mock-rpc-server-64-debug
----

==== Running The Mock Server
Launching the mock server is performed like this:

[source,bash]
----
 
trex-core/scripts> ./mock-rpc-server-64-debug

-= Starting RPC Server Mock =-

Listening on tcp://localhost:5050 [ZMQ]

Setting Server To Full Verbose

Server Started

----

==== Using The TRex Console To Interact
When the mock server is up, you can already send commands to the server.
{zwsp} +
{zwsp} +

Let's demonstrate the operation with the Python based TRex console:

{zwsp} +

[source,bash]
----
trex-core/scripts> ./trex-console

Connecting To RPC Server On tcp://localhost:5050
[SUCCESS]


-=TRex Console V1.0=-

Type 'help' or '?' for supported actions

TRex >

----
As we will see later on, a basic RPC command supported by the server is 'ping'.
{zwsp} +
Let's issue a ping command to the server and see what happens on both sides:

{zwsp} +
{zwsp} +

On the 'client' side:

[source,bash]
----
TRex > verbose on

verbose set to on

TRex > ping

-> Pinging RPC server
[verbose] Sending Request To Server:

{
    "id": "l0tog11a",
    "jsonrpc": "2.0",
    "method": "ping",
    "params": {}
}

[verbose] Server Response:

{
    "id": "l0tog11a",
    "jsonrpc": "2.0",
    "result": "ACK"
}

[SUCCESS]

----
On the 'server' side:

[source,bash]
----

trex-core/scripts> ./mock-rpc-server-64-debug

-= Starting RPC Server Mock =-

Listening on tcp://localhost:5050 [ZMQ]

Setting Server To Full Verbose

Server Started


[verbose][req resp] Server Received:

{
   "id" : "maa5a3g1",
   "jsonrpc" : "2.0",
   "method" : "ping",
   "params" : {}
}

[verbose][req resp] Server Replied:

{
   "id" : "maa5a3g1",
   "jsonrpc" : "2.0",
   "result" : "ACK"
}

----

== RPC Server State Machine
The RPC server can be in numbered of states, each state provides other subset of the commands
that are allowed to be executed.

We define the following possible states:

* *unowned* - The server is either unowned or another user is owning the device
* *owned* - The server has been acquired by the client
* *active* - The server is in the middle of injecting traffic - currently active

Each command will specify on which states it is possible to execute it.

For commands valid only on 'owned' or 'active', a field called ''handler'' 'MUST' be passed
along with the rest of the parameters.


This will identify the connection.

image::images/rpc_states.png[title="RPC Server States",align="left",width=200, link="images/rpc_states.png"]

== RPC Commands
The following RPC commands are supported

=== Ping
* *Name* - 'ping'
* *Valid States* - 'all'
* *Description* - Pings the TRex server
* *Paramters* - None
* *Result* - "ACK" On Sucess

Example:

[source,bash]
----
'Request':

{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "ping",
    "params": null
}

'Response':

{
   "jsonrpc" : "2.0",
   "id" : 1,
   "result" : "ACK"
}

----

=== Get Registered Commands
* *Name* - 'get_reg_cmds'
* *Valid States* - 'all'
* *Description* - Queries the server for all the registered commands
* *Paramters* - None
* *Result* - A list of all the supported commands by the server

Example:

[source,bash]
----
'Request':

{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "get_reg_cmds",
    "params": null
}


'Response':

{
    "jsonrpc": "2.0",
    "id": 1,
    "result": [
        "remove_all_streams",
        "remove_stream",
        "add_stream",
        "get_reg_cmds",
        "ping",
        "test_sub",
        "get_version",
        "test_add"
    ]
}

----


=== Get Version
* *Name* - 'get_version'
* *Valid States* - 'all'
* *Description* - Queries the server for version information
* *Paramters* - None
* *Result* - See table below

.Object type 'return values for get_version' 
[options="header",cols="1,1,3"]
|=================
| Field         | Type     | Description 
| version       | string   | TRex version
| build_date    | string   | build date
| build_time    | string   | build time
| built_by      | string   | who built this version
|=================

=== Get System Info
* *Name* - 'get_system_info'
* *Description* - Queries the server for system properties
* *Paramters* - None
* *Result* - See table below

.return value: 'get_system_info'
[options="header",cols="1,1,3"]
|=================
| Field          | Type     | Description 
| dp_core_count  | int      | DP core count
| core_type      | string   | DP core type
| hostname       | string   | machine host name
| ip             | string   | machine IP
| uptime         | string   | uptime of the server
| port_count     | int      | number of ports on the machine
| ports          | array    | arary of object ''port'' - see below
|=================

.return value: 'get_system_info'.'port'
[options="header",cols="1,1,3"]
|=================
| Field          | Type     | Description 
| driver         | string   | driver type
| speed          | string   | speed of the port (1g, 10g, 40g, 100g)
| status         | string   | up / down
|=================


=== Get Owner
* *Name* - 'get_owner'
* *Valid States* - 'all'
* *Description* - Queries the server for current owner
* *Paramters* - None
* *Result* ['string'] - owner name if exists, otherwise 'none'

[source,bash]
----

'Request':

{
    "id": "hxjkuwj9",
    "jsonrpc": "2.0",
    "method": "get_owner",
    "params": null
}

'Response':

{
    "id": "hxjkuwj9",
    "jsonrpc": "2.0",
    "result": {
        "owner": "itay"
    }
}

----

=== Acquire
* *Name* - 'Acquire'
* *Valid States* - 'all'
* *Description* - Takes ownership on the device.
* *Paramters* -
** *user* ['string'] - User name aquiring the system
** *force* ['boolean'] - force action even if another user is holding the device
* *Result* ['string'] - 'unique' identifier for future requests

[source,bash]
----

'Request':

{
    "id": "b1tr56yz",
    "jsonrpc": "2.0",
    "method": "Acquire",
    "params": {
        "force": false,
        "user": "itay"
    }
}


'Response':

{
    "id": "b1tr56yz",
    "jsonrpc": "2.0",
    "result": "4cBWDxS2"
}
----


=== Release
* *Name* - 'release'
* *Valid States* - 'owned'
* *Description* - Release owernship over the device
* *Paramters* -
** *handler* ['string'] - unique identifier for the message
* *Result* ['string'] - "ACK" on success

[source,bash]
----

'Request':

{
    "id": "m785dxwd",
    "jsonrpc": "2.0",
    "method": "release",
    "params": {
        "handler": "37JncCHr"
    }
}


'Response':

{
    "id": "m785dxwd",
    "jsonrpc": "2.0",
    "result": "ACK"
}
----


=== Add Stream
* *Name* - 'add_stream'
* *Valid States* - 'owned'
* *Description* - Adds a stream to a port
* *Paramters* 
** *port_id* - port id associated with this stream
** *stream_id* - stream id associated with the stream object
** *stream* - object of type xref:stream_obj['stream']
* *Result* - ACK in case of success

==== Object type 'stream' anchor:stream_obj[]

Add_stream gets a single parameter of type object.

The format of that object is as follows:

.Object type 'stream' 
[options="header",cols="1,1,3"]
|=================
| Field       | Type    | Description 
| enabled     | boolean | is this stream enabled
| self_start  | boolean | is this stream triggered by starting injection or triggered by another stream
| isg         | double  | ['usec'] inter stream gap - delay time in usec until the stream is started
| next_stream | int     | next stream to start after this stream. -1 means stop after this stream
| packet      | object  | object of type xref:packet_obj['packet']
| mode        | object  | object of type xref:mode_obj['mode']
| vm          | array   | array of objects of type xref:vm_obj['vm']
| rx_stats    | object  | object of type xref:rx_stats_obj['rx_stats']
|=================

===== Object type 'packet' anchor:packet_obj[]
packet contains binary and meta data

.Object type 'packet'
[options="header",cols="1,1,3"]
|=================
| Field       | Type        | Description
| binary      | byte array  | binary dump of the packet to be used in the stream as array of bytes
| meta        | string      | meta data object. opaque to the RPC server. will be passed on queries
|=================

===== Object type 'mode' anchor:mode_obj[]
mode object can be 'one' of the following objects:

.Object type 'mode - continuous' 
[options="header",cols="1,1,3"]
|=================
| Field       | Type        | Description
| type        | string      | ''continuous''
| pps         | double      | rate in packets per second 
|=================

.Object type 'mode - single_burst' 
[options="header",cols="1,1,3"]
|=================
| Field         | Type        | Description
| type          | string      | ''single_burst''
| pps           | double      | rate in packets per second 
| total pkts    | int         | total packets in the burst
|=================

.Object type 'mode - multi_burst' 
[options="header",cols="1,1,3"]
|=================
| Field          | Type        | Description
| type           | string      | ''multi_burst''
| pps            | int         | rate in packets per second 
| pkts_per_burst | int         | packets in a single burst
| ibg            | double      | ['usec'] inter burst gap. delay between bursts in usec
| count          | int         | number of bursts. ''0'' means loop forever, ''1'' will fall back to single burst
|=================

===== Object type 'vm' anchor:vm_obj[]
Array of VM instruction objects to be used with this stream

Any element in the array can be one of the following object types:

.Object type 'vm - fix_checksum_ipv4'
[options="header",cols="1,1,3"]
|=================
| Field       | Type        | Description
| type        | string      | ''fix_checksum_ipv4''
| pkt_offset  | uint16      | offset of the field to fix 
|=================

.Object type 'vm - flow_var'
[options="header",cols="1,1,3"]
|=================
| Field       | Type                        | Description
| type        | string                      | ''flow_var'''
| name        | string                      | flow var name - this should be a unique identifier
| size        | [1,2,4,8]                   | size of the flow var in bytes
| op          | ['inc', 'dec', 'random']    | operation type to perform on the field
| init value  | uint64_t as string          | init value for the field
| min value   | uint64_t as string          | minimum value for the field
| max value   | uint64_t as string          | maximum value for the field
|=================

.Object type 'vm - write_flow_var'
[options="header",cols="1,1,3"]
|=================
| Field         | Type        | Description
| type          | string      | ''write_flow_var''
| name          | string      | flow var name to write
| pkt_offset    | uint16      | offset at the packet to perform the write
| add_value     | int         | delta to add to the field prior to writing - can be negative
| is_big_endian | boolean     | should write as big endian or little 
|=================


===== Object type 'rx_stats' anchor:rx_stats_obj[]
Describes rx stats for the stream

{zwsp} +

'IMPORTANT':

In case rx_stats is enabled, meta data will be written in the end of the packet.

please consider the following:

==== Constrains
* *performance* - this will have performance impact as rx packets will be examined
* *override* - up to 10 bytes at the end of the packet will be overidden by the meta data required

==== The bytes needed for activating 'rx_stats':

* *rx_stream_id* consumes 2 bytes
* *seq_enabled* consumes 4 bytes
* *latency_enabled* consumes 4 bytes

so if no seq or latency are enabled 2 bytes will be used.


if seq or latency alone are enabled, 6 bytes will be used.


if both are enabled then 10 bytes will be used.


.Object type 'rx_stats'
[options="header",cols="1,1,3"]
|=================
| Field            | Type        | Description
| enabled          | boolean     | is rx_stats enabled for this stream
| seq_enabled      | boolean     | should write 32 bit sequence
| latency_enabled  | boolean     | should write 32 bit latency
|=================

[source,bash]
----

'Request':

{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "add_stream",
    "params": {
        "port_id": 1,
	"stream_id": 502
        "stream": {
            "enabled": true,
            "isg": 4.3,
            "mode": {
                "pps": 3,
                "total_pkts": 5000,
                "type": "single_burst"
            },
            "next_stream_id": -1,
            "packet": {
                "binary": [
                    4,
                    1,
                    255
                ],
                "meta": ""
            },
            "rx_stats": {
                "enabled": false
            },
            "self_start": true,
        }
    }
}

'Response':

{
    "id": 1,
    "jsonrpc": "2.0",
    "result": "ACK"
}


----


=== Remove Stream
* *Name* - 'remove_stream'
* *Valid States* - 'owned'
* *Description* - Removes a stream from a port
* *Paramters*
** *port_id* - port assosicated with the stream.
** *stream_id* - stream to remove

* *Result* - ACK in case of success

[source,bash]
----

'Request':

{
    "id": 1
    "jsonrpc": "2.0",
    "method": "remove_stream",
    "params": {
        "port_id": 1,
        "stream_id": 502
    }
}


'Response':

{
    "id": 1
    "jsonrpc": "2.0",
    "result": "ACK"
}

----

=== Get Stream ID List
* *Name* - 'get_stream_list'
* *Valid States* - 'owned', 'active'
* *Description* - fetch all the assoicated streams for a port
* *Paramters*
** *port_id* - port to query for registered streams

* *Result* - array of 'stream_id'

[source,bash]
----

'Request':

{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "get_stream_list",
    "params": {
        "port_id": 1
    }
}

'Response':

{
    "id": 1,
    "jsonrpc": "2.0",
    "result": [
        502,
        18
    ]
}


----

=== Get Stream
* *Name* - 'get_stream'
* *Valid States* - 'owned', 'active'
* *Description* - get a specific stream object
* *Paramters*
** *port_id* - port for the associated stream
** *stream_id* - the requested stream id

* *Result* - object xref:stream_obj['stream']

[source,bash]
----

'Request':

{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "get_stream",
    "params": {
        "port_id": 1,
        "stream_id": 7
    }
}


'Response':

{
    "id": 1,
    "jsonrpc": "2.0",
    "result": {
        "stream": {
            "enabled": true,
            "isg": 4.3,
            "mode": {
                "pps": 3,
                "type": "continuous"
            },
            "next_stream_id": -1,
            "packet": {
                "binary": [
                    4,
                    1,
                    255
                ],
                "meta": ""
            },
            "self_start": true
        }
    }
}

----


=== Remove All Streams
* *Name* - 'remove_all_streams'
* *Valid States* - 'owned'
* *Description* - remove all streams from a port
* *Paramters*
** *port_id* - port for the associated stream

* *Result* - "ACK" on success


[source,bash]
----

'Request':

{
    "id": 1,
    "jsonrpc": "2.0",
    "method": "remove_all_streams",
    "params": {
        "port_id": 2
    }
}

'Response':

{
    "id": 1,
    "jsonrpc": "2.0",
    "result": "ACK"
}


----


=== Start Traffic
* *Name* - 'start_traffic'
* *Valid States* - 'owned'
* *Description* - Starts the traffic on a specific port. if traffic has already started an error will be returned
* *Paramters*
** *port_id* - port for starting the traffic, -1 for starting all the ports

* *Result* - "ACK" on success

[source,bash]
----

'Request':

{   
    "id": "b3llt8hs",
    "jsonrpc": "2.0",
    "method": "start_traffic",
    "params": {
        "port_id": 3
    }

'Response':

{
    "id": "b3llt8hs",
    "jsonrpc": "2.0",
    "result": "ACK"
}


----

=== Stop Traffic
* *Name* - 'stop_traffic'
* *Valid States* - 'active'
* *Description* - Stops the traffic on a specific port. if the port has already started nothing will happen
* *Paramters*
** *port_id* - port for stopping the traffic, -1 for stopping all the ports

* *Result* - "ACK" on success

[source,bash]
----

'Request':

{
    "id": "h2fyhni7",
    "jsonrpc": "2.0",
    "method": "stop_traffic",
    "params": {
        "port_id": 3
    }
}

'Response':

{
    "id": "h2fyhni7",
    "jsonrpc": "2.0",
    "result": "ACK"
}


----


